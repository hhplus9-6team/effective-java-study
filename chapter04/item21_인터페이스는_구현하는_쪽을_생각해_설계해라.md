# ITEM21. 인터페이스는 구현하는 쪽을 생각하라

> **Default Method 이후, 인터페이스 설계는 더 강력해졌지만 그만큼 신중해야 한다.**

## 자바8 이후의 변화: 디폴트 메서드 (Default Method)

### 배경
- 자바8 부터 **기존 인터페이스에 메서드를 추가**할 수 있게 되었다.
- `default` 키워드를 사용하면, 해당 인터페이스를 구현한 클래스가 재정의하지 않아도 기본 구현을 **자동 상속**한다.

### 장점
- 기존 코드 수정 없이 새로운 기능을 추가 → **하위 호환성 유지**
- 자바8 에서 핵심 컬렉션 인터페이스에 람다식과 스트림 API 활용을 위한 기반 마련

### 주의점
- **모든 구현체의 불변식을 유지하는 디폴트 메서드 작성은 매우 어렵다.**
- 기존 구현체와 **의도치 않은 충돌**이 발생할 수 있다.
- 결과적으로 런타임 오류를 유발할 위험이 있다.

---

## 예시: `Collection.removeIf` 디폴트 메서드

```
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```
- 이 구현은 대부분의 Collection 구현체에서 잘 동작한다.
- 하지만 “동기화”나 “불변성” 등의 추가 제약을 가진 구현체에서는 문제가 생길 수 있다.

### 문제 사례: SynchronizedCollection (Apache Commons Collections)
- 내부 컬렉션 접근 시 락 객체를 이용해 동기화하는 래퍼 클래스이다.
- 하지만 removeIf의 기본 구현을 그대로 상속받으면, 락을 잡지 않고 내부 컬렉션을 수정하게 된다. → 스레드 안전성이 깨지고, 예기치 못한 동시성 오류가 발생할 수 있다.

### 자바 플랫폼의 대응
- 자바 표준 라이브러리(JDK)는 이런 문제를 인식하고 다음과 같이 조치했다.
- 기존의 컬렉션 클래스(Collections.synchronizedList, Collections.unmodifiableCollection 등)들은
대부분 디폴트 메서드를 재정의해 안전성을 확보했다.
- 하지만 외부(서드파티) 라이브러리는 이러한 보완이 이루어지지 않아 여전히 충돌 가능성이 있다.
---
## 결론 및 실무 가이드
### 1. 기존 인터페이스에 디폴트 메서드를 추가할 때
- 정말 필요한 경우에만 추가하라.
- 기존 구현체들과의 호환성 및 불변식 충돌 여부를 철저히 검토하라.
- “이 메서드가 모든 구현체에서 안전하게 동작하는가?”를 자문하라.

### 2. 디폴트 메서드는 “보완”용이지 “수정”용이 아니다
- 기존 메서드를 대체하거나 제거하기 위한 수단이 아니다.
- 공통 동작을 단순화하거나 새로운 기능을 보조적으로 제공할 때만 사용하라.

### 3. 새로운 인터페이스를 설계할 때
- 최소 세 가지 이상 방식으로 구현해보라.
- 예: 불변 구현, 동기화 구현, 동적 래퍼 구현 등
- 각 구현체를 실제로 사용하는 클라이언트 코드를 다양하게 만들어 테스트하라.
- 릴리즈 전에는 서로 다른 상황에서의 동작을 충분히 검증하라.
