# item67. 최적화는 신중히 하라


**언제, 어디에서, 어떤 수준으로 최적화를 해야 하는지**를 설명한다.

- 구현 단계에서의 성능 문제는 나중에 수정할 수 있다
- 하지만 **아키텍처와 설계 단계의 결정은 성능을 영구적으로 제한할 수 있다**
- 따라서 **설계 단계에서는 성능을 반드시 염두에 두어야 한다**


## 성능을 제한하는 설계를 피하라

시스템이 완성된 뒤 변경하기 가장 어려운 요소들은 다음과 같다

- 컴포넌트 간 경계
- 외부 시스템과의 통신 방식
- API
- 네트워크 프로토콜
- 영구 저장 데이터 포맷

이러한 요소들은
- 변경 비용이 매우 크거나
- 사실상 변경이 불가능한 경우도 많고
- 동시에 **시스템 전체 성능을 심각하게 제한할 수 있다**

따라서 **설계 단계에서 성능을 고려하지 않은 선택은 큰 위험을 가진다**


## API 설계는 성능에 직접적인 영향을 준다

### 1. 가변 public 타입
- public 타입을 가변으로 설계하면
- 내부 데이터를 보호하기 위해 방어적 복사가 필요해지고
- 이는 반복적인 성능 비용으로 이어진다  
  (아이템 50)

### 2. 상속을 강제하는 API
- 컴포지션으로 해결할 수 있음에도
- 상속을 사용하도록 설계한 public 클래스는
- 성능 특성까지 상위 클래스에 종속된다  
  (아이템 18)

### 3. 구현 타입에 종속된 API
- 인터페이스 대신 구현 클래스를 노출하면
- 나중에 더 나은 성능의 구현체가 나와도 교체할 수 없다  
  (아이템 64)


## 실제 사례: Component.getSize()

- `java.awt.Component.getSize()`는
  `Dimension` 객체를 반환하도록 설계되었다
- `Dimension`은 가변 객체이기 때문에
  호출할 때마다 방어적 복사가 필요하다
- 그 결과, 반복 호출 시 객체 생성 비용이 누적된다

### 가능한 대안
- `Dimension`을 불변으로 설계했을 수도 있고
- `getWidth()`, `getHeight()`처럼
  기본 타입 값을 반환하는 API를 제공할 수도 있었다

실제로 자바 2에서는
- `getWidth()`, `getHeight()` 메서드가 추가되었지만
- 기존 `getSize()` API는 제거할 수 없었고
- 초기 설계로 인한 비용은 계속 유지된다

**API 설계 실수는 장기적인 성능 비용으로 남는다**


## 구현을 마친 후에는 반드시 측정하라

자바의 성능 모델은 다음 이유로 예측하기 어렵다

- JVM 구현 차이
- 릴리스 버전 차이
- 라이브러리 차이
- 하드웨어 및 플랫폼 차이

따라서:
- 최적화의 효과는 추측할 수 없으며
- **최적화 전후의 성능을 반드시 측정해야 한다**
- 여러 플랫폼에서 실행된다면
  각 환경에서 개별적으로 측정해야 한다


## 프로파일링 도구를 사용하라

- 프로그램 실행 시간의 대부분은
  코드의 일부에서 소비된다
- 성능 병목은 직관으로 찾기 어렵다

프로파일링 도구는
- 메서드별 실행 시간
- 호출 횟수
- 집중적으로 최적화해야 할 지점
을 보여준다

특히
- 잘못된 알고리즘을 사용하고 있다면
  다른 저수준 최적화는 의미가 없다
- **먼저 알고리즘을 점검해야 한다**


