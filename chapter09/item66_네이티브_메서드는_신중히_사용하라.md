# item66. 네이티브 메서드는 신중히 사용하라

> [!IMPORTANT]  
> 네이티브 메서드는 자바의 안전성과 이식성을 해치고 유지보수 비용을 높이므로 **정말 필요한 상황에서만 사용해야 한다.**    
> JVM이 제공하지 않는 기능을 써야 할 때를 제외하면 순수 자바 코드가 훨씬 안전하다.


## 네이티브 메서드란?
- 자바 코드가 아닌 **C, C++ 등의 언어로 작성된 코드(JNI)** 를 자바에서 호출하는 방식
- 운영체제 기능 접근, 기존 C/C++ 라이브러리 연동, 성능 최적화 목적 등으로 사용된다

### 네이티브 메서드 간단 예시 (JNI)

#### 1. 자바 코드에서 네이티브 메서드 선언
```java
public class NativeExample {
    // C 언어로 구현될 네이티브 메서드
    public native int add(int a, int b);

    static {
        // 네이티브 라이브러리 로드
        System.loadLibrary("native-lib");
    }
}
```

#### 2. `javac`로 컴파일 후 JNI 헤더 생성
```bash
javac NativeExample.java
javah -jni NativeExample
```

#### 3. C 코드 구현 예시 (`native-lib.c`)
```c
#include <jni.h>
#include "NativeExample.h"

JNIEXPORT jint JNICALL Java_NativeExample_add
  (JNIEnv *env, jobject obj, jint a, jint b) {
    return a + b;
}
```

#### 4. 컴파일 및 라이브러리 생성  
(운영체제에 따라 `.so`, `.dll`, `.dylib` 형태로 생성)
```bash
gcc -shared -o libnative-lib.so -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" native-lib.c
```

#### 5. 자바에서 호출
```java
public class Main {
    public static void main(String[] args) {
        NativeExample ex = new NativeExample();
        System.out.println(ex.add(3, 5)); // 8 출력
    }
}
```

> 이 예시는 JNI의 기본 구조(자바 선언 → 네이티브 구현 → 라이브러리 로드 → 호출)를 보여주는 최소 예제다.

## 네이티브 메서드를 사용해야 하는 상황

### 1. JVM이 제공하지 않는 기능을 꼭 사용할 때
- 특정 운영체제 API나 하드웨어 기능이 필요한 경우
- 자바 표준 라이브러리로 구현할 방법이 없는 경우에만 사용

### 2. 기존 고성능 C/C++ 라이브러리를 활용해야 할 때
- 수십 년간 사용되며 안정성이 검증된 C 라이브러리를 그대로 활용해야 하는 경우
- 재작성 비용이 지나치게 높을 때

### 3. 성능 최적화가 반드시 필요한 특수한 상황  
- 과거에는 네이티브 코드가 자바보다 월등히 빨랐으나  
  **오늘날 JVM(JIT)의 최적화는 매우 강력해 대부분의 경우 자바가 비슷하거나 더 빠르다.**

### 추가 사례: GMP와 같은 고성능 정밀 연산 라이브러리
- 과거에는 C로 작성된 GNU 다중 정밀 연산 라이브러리(GMP)와 같은 고성능 라이브러리를 활용하기 위해 네이티브 메서드를 사용하곤 했다.

## 네이티브 메서드 사용 시 문제점

### 1. 자바의 안전성을 깨뜨린다
- C/C++은 메모리에 직접 접근하므로 **메모리 훼손, 버퍼 오버플로, JVM 크래시** 위험이 있다  
- 자바의 가비지 컬렉터, 예외 처리, 메모리 보호 장치가 모두 적용되지 않음

#### 근거  
자바는 포인터 연산을 허용하지 않아 프로그램 전체가 중단되는 일이 거의 없다.  
그러나 네이티브 코드에서 포인터 오류가 발생하면 **JVM 자체가 중단될 수 있다.**

### 2. 유지보수 복잡도 증가
- 자바 + C/C++ 두 언어를 모두 관리해야 한다
- 플랫폼별 바이너리 빌드 과정이 필요해 배포가 복잡해진다
- 운영체제마다 동작이 달라질 수 있어 디버깅도 어려움

#### 근거  
JNI 기반 라이브러리는 Windows, macOS, Linux 각각에 맞춘 네이티브 파일을 제공해야 하며,  
이는 일반적인 자바 라이브러리보다 배포 난이도를 크게 높인다.

### 3. 성능 오버헤드가 존재한다
- JNI 호출 자체가 비용이 크다
- 작은 연산을 위해 자주 호출하면 오히려 순수 자바보다 느려질 수 있음

#### 근거  
JNI는 자바 ↔ 네이티브 간 데이터 복사 및 변환 과정이 필요하며,  
빈번한 호출은 성능저하를 야기한다는 것이 여러 사례에서 확인되었다.

### 4. 테스트와 배포 난이도 상승
- CI/CD 환경마다 네이티브 라이브러리 설정이 필요
- 환경 차이로 인해 테스트 결과가 일정하지 않을 수 있음

### 5. 네이티브 환경에서 버그 발생 확률 증가
- 네이티브 코드는 자바의 보호 장치를 벗어나 있어 단 한 줄의 실수도 심각한 오류로 이어질 수 있다.
- 포인터 오류, 메모리 해제 누락, 버퍼 오버플로 같은 문제는 JVM 전체를 중단시킬 수 있으며, 발견도 어렵다.
- 디버깅 역시 자바보다 훨씬 복잡하며, 오류의 근원이 네이티브 영역에 있을 경우 추적이 난해해진다.

### 6. Glue Code(접착 코드) 작성 부담
- 네이티브 라이브러리와 자바 코드를 연결하기 위해 별도의 Glue Code를 작성해야 한다.
- 이는 **반복적이고 귀찮은 작업**일 뿐 아니라 **유지보수 비용도 높다.**
- Glue Code는 자바와 네이티브 사이의 변환/호출 규약을 다루므로 **오류가 발생하기 쉽다.**


## 핵심 정리
- 네이티브 메서드를 사용하려면 한 번 더 신중하게 생각하라.
- 저수준 자원이나 네이티브 라이브러리를 반드시 사용해야 하는 상황이 아니라면 대체 수단을 먼저 고려하라.
- 네이티브 코드는 최소한만 사용하며 철저하게 테스트해야 한다.
- 네이티브 코드 내부의 작은 버그 하나가 애플리케이션 전체를 위험에 빠뜨릴 수 있다.

## QnA  
Q. 네이티브 메서드를 신중히 사용해야 하는 이유는 무엇인가?
