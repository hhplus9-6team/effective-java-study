# item 69. 예외는 진짜 예외 상황에만 사용하라
>* **예외는 진짜 예외 상황에만 사용하라.**
> * 실패가 정상적인 흐름이라면,
> 
>    * 예외가 아니라
>    * API 설계(상태 검사, Optional, 특정 값)로 표현하라.

## 1. 개요

* 예외는 **정상적인 제어 흐름**을 위한 수단이 아니다.
* 실패가 **예측 가능하고 흔한 상황**이라면 예외 대신 **API 설계**로 표현해야 한다.
* 이를 위해 책은 **상태 검사 메서드, Optional, 특정 값** 중 하나를 선택하라고 지침을 제시한다.

---

## 2. 예외를 제어 흐름에 사용하면 안 되는 이유

* 예외는

    * 가독성을 해치고
    * 성능 비용이 크며
    * 의도를 흐린다.
* 특히 반복문이나 정상 분기에서 예외를 사용하면

    * 코드가 의도를 숨기고
    * 성능까지 악화된다.

---
## 3. 올바른 제어흐름 API
### 3.1. 상태검사 메서드
```java
Iterator<String> it = list.iterator();

if (it.hasNext()) {           // 상태검사
    String v = it.next();     // 안전
}
```
#### 상태검사를 사용하기 특히 좋을 때
* 실패가 예측 가능하고(자주 일어남) 클라이언트가 쉽게 회피할 수 있을 때
* “실패가 예외적 상황”이 아니라 “흔한 분기”일 때
* 특히 반복/루프처럼 호출 빈도가 높을 때
#### 주의점
* 상태검사와 실제 동작 사이에 상태가 바뀌면 레이스가 생길 수 있다.
* 이런 경우 동기화처리 하거나 단일 호출로 해결(Optional)을 권장

### 3.2. Optional
```java
public OptionalInt max(int[] arr) {
    if (arr.length == 0) return OptionalInt.empty();

    int m = arr[0];
    for (int v : arr) m = Math.max(m, v);
    return OptionalInt.of(m);
}
```
사용하는 쪽:
```java
OptionalInt m = max(arr);

int value = m.orElse(0);                // 기본값
m.ifPresent(System.out::println);       // 있을 때만 처리
```
#### Optional을 사용하기 특히 좋을 때
* "없음"이 정상적인 결과 중 하나일 때 (예: 검색결과 없음)
* 호출자가 그 케이스를 반드시 고려하게 만들 고 싶을 때
* null을 반환하기 싫을 때

#### Optional의 주의점
* Optional이 객체라서 성능상 오버헤드가 될 수 있다.
* "없음"이 아니라 진짜로 프로그램 오류라면 예외가 맞다.

### 3.3. 특정값(센티넬)
#### 예시 1 : indexOf의 -1
```java
int idx = "abc".indexOf("z"); // -1
```
#### 예시 2: Map.get의 null
```java
String v = map.get(key); // 없으면 null
```
#### 센티넬의 좋은 조건
* 유효한 값 범위와 절대 겹치지 않는 값을 보장할 수 있을 때
* 호출자 입장에서 처리가 너무 번거롭지 않을 때

#### 주의할 점
* "약속을 모르면" 그냥 정상 값처럼 써버리기 쉽다
* 타입이 강제해주지 않아서 호출자 실수가 늘기 쉽다.
* 겹침 문제가 생기면 설계가 급격히 취약해진다.

## 4. 제어흐름 선택지 선택 지침

### 4.1 지침 1

### 외부 동기화 없이 여러 스레드가 접근하거나, 외부 요인으로 상태가 변할 수 있다면
### → Optional 또는 특정 값을 사용하라

* 상태 검사 메서드 방식은 호출이 **두 단계**로 나뉜다.

    * 상태 검사
    * 상태 의존적 메서드 호출
* 이 두 호출 사이에 객체의 상태가 변하면 문제가 된다.

```java
if (obj.isAvailable()) {
    obj.use();
}
```

* 멀티스레드 환경
* 시간 경과, I/O, 네트워크 등 외부 요인
  → `isAvailable()`과 `use()` 사이의 전제가 깨질 수 있다.

이런 경우:

* 상태 검사 자체가 무의미해질 수 있으므로
* 상태 판단과 결과를 **한 번의 호출로 묶는 방식**이 필요하다.

```java
Optional<Resource> r = obj.tryGet();
```

* 호출 시점의 상태를 한 번에 반영
* 상태 변화에 더 안전한 설계

---

### 3.2 지침 2

### 성능이 중요한 상황에서 상태 검사 메서드가

### 상태 의존적 메서드의 작업 일부를 중복 수행한다면

### → Optional 또는 특정 값을 사용하라

* 상태 검사 메서드가 내부적으로

    * 탐색
    * 계산
    * 락 획득
      같은 비용 있는 작업을 수행할 수 있다.
* 상태 의존적 메서드도 같은 작업을 다시 수행하면

    * **중복 비용**이 발생한다.

```java
if (!collection.isEmpty()) {
    collection.remove();
}
```

* `isEmpty()`와 `remove()`가 내부 검사를 각각 수행할 수 있음
* 성능이 중요한 코드에서는 치명적

이 경우:

* 상태 검사 + 동작을 **한 번의 메서드 호출**로 합치는 편이 낫다.

```java
Optional<E> removed = collection.tryRemove();
```

---

### 3.3 지침 3

### 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다

책이 말하는 **기본 선택지**다.

#### 이유 1. 가독성

```java
if (it.hasNext()) {
    it.next();
}
```

* 흐름이 명확하다.
* 조건과 동작이 분리되어 의도가 잘 드러난다.

#### 이유 2. 잘못 사용했을 때 버그가 빨리 드러난다

```java
it.next(); // 상태 검사 누락
```

* 즉시 예외 발생
* 버그가 조용히 숨지 않고 바로 노출된다.

반면:

* Optional이나 특정 값은

    * 호출자가 처리를 누락해도
    * 조용히 실패할 가능성이 있다.

따라서:

* 상태가 안정적이고
* 단일 스레드 환경이며
* 상태 검사 비용이 크지 않다면
  → 상태 검사 메서드 방식이 가장 안전하다.

## QnA
* 제어흐름용 API사용 지침 3가지 나열하기