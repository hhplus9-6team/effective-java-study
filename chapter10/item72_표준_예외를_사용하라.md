# item72. 표준 예외를 사용하라

> [!IMPORTANT]  
> **새로운 예외를 직접 정의하기 전에, 표준 예외로 표현할 수 있는지 먼저 검토하라.**  
> 표준 예외를 사용하면 API는 더 이해하기 쉬워지고, 유지보수 비용도 줄어든다.

## 표준 예외 사용 이점

- API 사용자에게 의미가 즉시 전달된다
- 문서를 보지 않아도 예외의 성격을 추측할 수 있다
- API를 사용하는 코드가 더 읽기 쉬워진다
- 예외 클래스 수가 줄어들어
    - 메모리 사용량이 감소하고
    - 클래스 로딩 시간도 줄어든다

이러한 이유로,  **숙련된 프로그래머일수록 예외를 새로 만들지 않고 재사용한다**


## 가장 자주 사용되는 표준 예외들

### 1. IllegalArgumentException
- 메서드에 전달된 **인수가 부적절할 때** 던진다
- 예) 반복 횟수에 음수를 전달한 경우


### 2. IllegalStateException
- **객체의 상태가 메서드를 수행하기에 적절하지 않을 때** 던진다
- 예) 아직 초기화되지 않은 객체를 사용하는 경우


### IllegalArgumentException vs IllegalStateException

둘 중 어떤 예외를 던져야 할지 헷갈릴 수 있다  
책에서 제시하는 일반적인 기준은 다음과 같다

- **인수 값과 상관없이 항상 실패한다면** → `IllegalStateException`
- **특정 인수 값 때문에 실패한다면** → `IllegalArgumentException`

### 3. NullPointerException
- null을 허용하지 않는 메서드에 null을 전달했을 때 던진다
- 관례적으로 `IllegalArgumentException`보다 더 적절하다


### 4. IndexOutOfBoundsException
- 시퀀스의 허용 범위를 벗어난 인덱스를 전달했을 때 던진다
- `IllegalArgumentException`보다 더 구체적인 예외다


### 5. ConcurrentModificationException
- 단일 스레드 사용을 전제로 설계된 객체를
  여러 스레드가 동시에 수정하려 할 때 던진다
- 이 예외는 **동시 수정이 감지되었을 가능성**을 알리는 용도로 사용된다
- 동시 수정을 완벽히 검출할 수 있는 방법은 없다


### 6. UnsupportedOperationException
- 객체가 요청된 연산을 지원하지 않을 때 던진다
- 주로 구현하지 않은 인터페이스 메서드를 호출했을 때 사용된다
- 예) 변경을 허용하지 않는 `List` 구현체에서 `remove()` 호출


## 사용하면 안 되는 예외들

다음 예외들은 **직접 던지거나 재사용해서는 안 된다**

- `Exception`
- `RuntimeException`
- `Throwable`
- `Error`

이 예외들은 다른 예외들의 상위 클래스로, 너무 포괄적이어서
- 오류의 성격을 명확히 드러내지 못하고
- 테스트와 오류 처리 모두를 어렵게 만든다


## 표준 예외를 사용할 때의 원칙

- 항상 API 문서를 확인하라
- 예외의 이름이 아니라
  **실제로 던져지는 상황이 의미에 맞는지**를 기준으로 선택하라
- 더 구체적인 표준 예외가 있다면 그것을 우선 사용하라
- 단순히 “정보를 더 주기 위해” 새 예외를 만들지 말라
