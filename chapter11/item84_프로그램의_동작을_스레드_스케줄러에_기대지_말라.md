# item84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

## 스레드 스케줄러

여러 스레드가 실행 중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다. 

- 정상적인 운영체제라면 이 작업을 공정하게 수행하지만, 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다
- 스케줄링 정책에 따라 프로그램의 성능이 달라지면 안 된다
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다


## 견고하고 이식성이 좋은 프로그램을 만드는 법

### 실행 가능한 스레드 수 제한

- 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 설계해야 한다.

#### 실행 가능한 스레드 수를 적게 유지하는 방법

각 스레드가 일을 마치면 다음 일거리가 생길 때까지 대기시키는 것이 하나의 방법이 될 수 있다.

- 적절히 스레드 풀 사이즈를 설정
- 작업은 짧게 유지


## Busy Waiting 상태가 되면 안된다

공유 객체의 상태가 바뀔 때까지 기다려서는 안 된다. 바쁜 대기는 CPU를 낭비하고 다른 스레드가 실행될 기회를 박탈한다.


```java
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0)
            throw new IllegalArgumentException(count + " < 0");
        this.count = count;
    }

    public void await() {
        while (true) {
            synchronized(this) {
                if (count == 0)
                    return;
            }
            //CPU를 낭비함
        }
    }

    public synchronized void countDown() {
        if (count != 0)
            count--;
    }
}
```



## Thread.yield

### Thread.yield() 메서드

- 실행 중인 스레드를 실행 대기 상태(Runnable)로 변경하는 메서드


### 특정 스레드가 다른 스레드들과 비교해 CPU시간을 충분히 얻지 못해서 간실히 돌악는 프로그램을 봐도 사용하지 말자

- 처음 JVM에서는 높은 성능을 보여주다가도 두 번째 JVM에서는 그렇지 못할 수 있음
- 이식성이 좋지 않음
- 이를 테스트할 수 있는 수단도 존재하지 않다

#### 왜 이식성 면에서 좋지 않은가?

- JVM 구현체마다 동작이 다름
  - 어떤 JVM에서는 `Thread.yield()`가 실제로 동작하지만, 다른 JVM에서는 무시할 수도 있음
  - 처음 JVM에서는 높은 성능을 보여주다가도 두 번째 JVM에서는 그렇지 못할 수 있음
  
- 운영체제별로 스레드 스케줄링 정책이 다름
  - Windows, Linux, macOS 등 운영체제마다 스레드 스케줄링 방식이 다름
  - 같은 코드라도 실행 환경에 따라 다른 결과를 낼 수 있음
  
- 테스트할 수 있는 수단이 없음
  - `yield()`가 실제로 효과가 있는지 검증하기 어려움
  - 성능 향상이 `yield()` 때문인지 다른 요인 때문인지 구분하기 어려움


## 스레드 우선순위에 의존하지 말 것

스레드 몇 개의 우선순위를 조율해서 애플리케이션의 반응 속도를 높이는 것도 타당할 수 있지만, 이것이 적합한 상황은 드물고 이식성이 떨어진다.

### 왜 이식성이 떨어지는가?

- 운영체제별로 우선순위 처리 방식이 다름
  - Windows, Linux, macOS 등 운영체제마다 스레드 우선순위를 처리하는 방식이 다름
  - Java의 우선순위 레벨(1~10)이 운영체제의 실제 우선순위로 매핑되는 방식이 다를 수 있음
  
- JVM 구현체마다 동작이 다를 수 있음
  - 같은 우선순위 설정이라도 JVM 구현체에 따라 다르게 동작할 수 있음
  
- 프로그램의 정확성을 우선순위에 의존하면 안 됨
  - 우선순위는 스케줄러에게 힌트를 제공할 뿐, 반드시 반영된다는 보장이 없음
  - 우선순위 역전(priority inversion) 같은 문제가 발생할 수 있음


## QnA

Q1. Thread.yield()와 스레드 우선순위에 의존하지 말아야 하는 이유는 무엇인가요? 
---

## 참고 자료

- Joshua Bloch, Effective Java, 3rd Edition, Item 84
