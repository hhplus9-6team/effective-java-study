# item80. 스레드보다는 실행자, 태스크, 스트림을 애용하라

- **태스크(Task)** = “해야 할 일(작업 내용)”
- **실행자 서비스(ExecutorService)** = “그 일을 어떤 스레드로 어떻게 실행할지(수행 정책)를 책임지는 곳”

👉 핵심은 **‘할 일’과 ‘실행 방식’을 분리**하는 것이다.


## 예전 방식(작업 큐) vs 실행자 프레임워크

초판의 작업 큐 방식은 개념을 이해하기엔 좋지만, 실제로 서비스/앱에 쓰려면 금방 복잡해진다.

- 안전한 종료
- 실패/응답 불가 상황 처리
- 예외로 전체가 망가지지 않게 방어

2판 이전에 `java.util.concurrent`가 도입되면서, 인터페이스 기반의 유연한 태스크 실행 기능(= **실행자 프레임워크**)이 제공되었고,
작업 큐를 **더 단순하고 더 안전하게** 만들 수 있게 되었다.


## 간단 실행자 서비스 사용 예시

단일 워커 스레드 기반의 ‘작업 큐’를 한 줄로 만든다.

```java
ExecutorService exec = Executors.newSingleThreadExecutor();
```

태스크(작업)를 실행자에 넘긴다.

```java
exec.execute(runnable);
```

사용이 끝나면 실행자를 **종료**한다.

```java
exec.shutdown();
```


## 실행자 서비스가 제공하는 주요 기능

실행자 서비스는 기본 실행/종료 외에도 대표적으로 다음을 지원한다.

- 특정 태스크가 끝나기를 기다린다(`get`메서드 | 79-2)
- 태스크 모음 중 **아무거나 하나**가 끝나기를 기다린다(`invokeAny`)
- 태스크 모음 **전체**가 끝나기를 기다린다(`invokeAll`)
- 실행자 서비스가 **종료되기를** 기다린다(`awaitTermination`)
- 완료된 태스크 결과를 **완료 순서대로** 받는다(`ExecutorCompletionService`)
- 태스크를 특정 시각/주기로 실행한다(`ScheduledThreadPoolExecutor`)

**“스레드를 직접 만들면 직접 구현해야 하는 것들”을 실행자 서비스가 표준 기능으로 제공한다.**


## 스레드풀 만들기: 정적 팩터리 vs 직접 구성

큐를 **둘 이상의 스레드**가 처리하게 하고 싶다면, `Executors`의 다른 정적 팩터리를 이용해 다양한 실행자(스레드 풀)를 만들면 된다.

- 스레드 개수를 **고정**할 수도 있고
- 필요에 따라 **늘거나 줄게** 할 수도 있다

대부분은 `Executors`의 정적 팩터리로 충분하다.

** `ThreadPoolExecutor`를 직접 써서 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있다.


## 풀 선택 주의: `newCachedThreadPool()`

작은 프로그램/가벼운 서버라면 `Executors.newCachedThreadPool()`이 범용적으로 괜찮을 수 있다.

하지만 **무거운 프로덕션 서버**에서는 조심해야 한다.

- `CachedThreadPool`은 요청받은 태스크가 **큐에 쌓이지 않고** 즉시 스레드에 위임되어 실행된다
- 가용 스레드가 없으면 **새 스레드를 생성**한다
- 서버가 과부하일 때 CPU 사용률이 100%에 가까워지고,
  새 태스크가 들어올수록 스레드를 더 만들며 상황을 악화시킬 수 있다

따라서 무거운 프로덕션 서버에서는
- 스레드 개수를 고정한 `Executors.newFixedThreadPool()`을 택하거나
- 완전히 통제 가능한 `ThreadPoolExecutor`를 직접 쓰는 편이 낫다


## 태스크: `Runnable`과 `Callable`

이 프레임워크에서 작업 단위를 나타내는 핵심 추상 개념이 **태스크**다.

- `Runnable`
- `Callable` : `Runnable`과 비슷하지만 **값을 반환**하고, **임의의 예외를 던질 수 있다**

태스크를 수행하는 일반적인 메커니즘이 **실행자 서비스**다.

태스크 수행을 실행자 서비스에 맡기면
- 원하는 **태스크 수행 정책**을 선택할 수 있고
- 생각이 바뀌면 언제든 **정책을 변경**할 수 있다

핵심 아이디어는
(컬렉션 프레임워크가 데이터 모음을 담당하듯)
**실행자 프레임워크가 작업 수행을 담당한다**는 점이다.


## 7) 포크-조인과 병렬 스트림

자바 7부터 실행자 프레임워크는 **포크-조인(fork-join) 태스크**까지 지원하도록 확장되었다.

- 포크-조인 태스크는 **포크-조인 풀**이라는 특별한 실행자 서비스가 실행한다
- 포크-조인 태스크(`ForkJoinTask`)는 작은 하위 태스크로 나눌 수 있다
- `ForkJoinPool`의 스레드들이 이를 처리한다
- 먼저 일을 끝낸 스레드가 다른 스레드의 남은 태스크를 가져와 처리할 수도 있다(작업 훔치기)
  - 결과적으로 CPU를 최대한 활용해서 **처리량을 높이고 지연시간을 낮추는** 데 도움이 된다

포크-조인 태스크를 직접 작성하고 튜닝하는 일은 어렵지만,
포크-조인 풀을 이용해 만든 **병렬 스트림(아이템 48)** 을 사용하면
상대적으로 적은 노력으로 이점을 얻을 수 있다(물론 포크-조인에 적합한 형태의 작업이어야 한다).


## 질문

Q1. `Runnable`과 `Callable`의 차이는 무엇인가?   
Q2. 작업 단위(태스크)와 실행 정책(실행자 서비스)을 분리하면 어떤 점이 좋아지나?
