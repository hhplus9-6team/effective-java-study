# item41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

### 마커 인터페이스란?
- 메서드가 하나도 없는 인터페이스
- 단지 "이 타입은 특정 속성을 가졌다"는 표식 역할을 한다.
- 예시: `Serializable`
  - 이 인터페이스를 구현한 클래스의 인스턴스는 직렬화 가능함을 의미
  - 자신을 구현한 인스턴스는 `ObjectOutputStream.writeObject` 을 통해 write 할 수 있다고 표시

### 마커 인터페이스의 장점
#### 1. 타입 안정성을 제공한다. 
- 마커 인터페이스는 실제 “타입”이므로, 컴파일러가 이를 이용해 컴파일 시점에 오류를 잡을 수 있다.
- 예시: `Serializable`을 구현하지 않은 객체를 `writeObject()`에 넘기면 컴파일 단계에서 경고 가능.
- 반면, 마커 애너테이션은 타입 정보가 아니므로 런타임에야 오류를 발견한다.

#### 2. 적용 대상을 더 정밀하게 지정할 수 있다.
- 애너테이션은 @Target(ElementType.TYPE)으로 선언하면 클래스, 인터페이스, 열거형 등 모든 타입에 붙일 수 있어 너무 광범위함.
- 마커 인터페이스는 특정 계층에만 구현하도록 제한할 수 있음.
- 예시: `Set`은 `Collection`의 하위 타입에서만 의미가 있으며, `Collection` 이 정의한 메서드 외에는 새로 추가하는 것이 없다.
- 객체의 특정 부분을 불변식으로 규정하거나, 그 타입의 인스턴스는 다른 클래스의 특정 메서드가 처리할 수 있다는 사실을 명시하는 용도로 사용

### 마커 애너테이션의 장점
#### 1. 애너테이션 시스템의 통합된 지원
- 리플렉션, 스프링, JUnit 등 프레임워크 단위에서 일관된 방식으로 탐색 및 처리 가능
- 메타데이터 기반 프로그래밍(예: @Entity, @Deprecated)에 자연스럽게 통합됨

### 언제 어떤 걸 써야 하나?
| 상황                                                                 | 권장 방식         | 이유                             |
| ------------------------------------------------------------------ | ------------- | ------------------------------ |
| **클래스 / 인터페이스에 특정 속성을 표시하고**, <br>**그 타입을 매개변수로 받는 메서드를 작성해야 할 때** |  **마커 인터페이스** | 타입 계층에서 안전하게 구분 가능 (컴파일 타임 검사) |
| **메서드, 필드, 패키지 등 클래스 외 요소에 표시해야 할 때**                              |  **마커 애너테이션** | 인터페이스는 클래스/인터페이스 외엔 구현 불가      |
| **프레임워크나 리플렉션 기반 시스템에서 일관된 메타데이터로 활용할 때**                          |  **마커 애너테이션** | 애너테이션 시스템과의 통합성 유리             |


### 질문
- 왜 마커 인터페이스는 컴파일 타임에 오류를 잡을 수 있지만, 마커 애너테이션은 그렇지 않을까요?
- 어떤 경우에 마커 인터페이스가 더 적합하고, 어떤 경우에 마커 애너테이션이 더 적합한가요?