# item 86. `Serializable`을 구현할지는 신중히 결정하라
> Serializable을 무턱대고 구현하지 말자

## 1. 핵심 요지
* `Serializable`은 **한 번 구현하면 되돌리기 거의 불가능한 공개 API 결정**이다.
* 편리해 보이지만 **유지보수, 보안, 성능, 진화성** 측면에서 장기적인 비용이 매우 크다.
* **“일단 붙이고 보자”는 가장 위험한 선택**이다.

---

## 2. `Serializable`이 위험한 이유

### 2.1 API에 영구적인 짐을 얹는다

* 직렬화 형식은 **공개 API의 일부**가 된다.
* 필드 이름, 타입, 구조가 **영원히 호환 대상**이 된다.
* 이후 필드 변경, 제거, 타입 변경이 극도로 어려워진다.

> 한 번 릴리스된 직렬화 형태는 사실상 **영구 계약**이다.

---

### 2.2 캡슐화를 심각하게 깨뜨린다

* 직렬화는 **생성자를 우회**한다.
* 불변식(invariant)을 생성자에서 보장해도:
    * 역직렬화 시 **무력화**될 수 있다.
* private 변수같은 내부 구현 디테일이 외부로 노출된다.

---

## 3. 클래스 진화(Class Evolution)가 매우 어렵다

`Serializable` 클래스에서 흔히 겪는 문제:

* 필드 추가 → `serialVersionUID` 충돌
  * `serialVersionUID`은 직렬화과정때 값, 클래스 이름 등을 조합하여 자동으로 생성되는 Hash값이다.
* 필드 제거 → 이전 데이터 복원 불가
* 타입 변경 → `InvalidClassException`
* 상속 구조 변경 → 예상 불가 동작

> 클래스를 변경하기 굉장히 어려움

---

## 4. 그럼 언제 `Serializable`을 써도 되는가?

### 4.1 **값 클래스(value class)** 이고

* 불변(immutable)
* 논리적으로 단순
* 장기적으로 구조 변경 가능성이 거의 없을 때

예:

* `BigInteger`, `Instant` 같은 **수학적/시간적 값 객체**

---

### 4.2 **프레임워크 요구사항**일 때

* 일부 레거시 API
* 반드시 필요하다면:

    * **직렬화 프록시 패턴(Item 90)** 과 함께 사용

---

## 5. 왜 직렬화를 사용해본 적이 없을까?

### 5.1 명시적 직렬화 포맷 사용하기 때문
```text
Domain Model  ←→  DTO  ←→  JSON/Protobuf
```
* JSON / XML
* DTO를 따로 두고 변환하는 방식을 사용
> 도메인 객체는 순수하게 유지하고, 직렬화 책임을 외부로 분리하여 사용

### 5.2. 왜 Gson / JSON 방식이 “의식적으로 안전한 설계”인가

#### 5.2.1 직렬화 대상이 명확하다

* JSON 필드 = **의도적으로 공개한 데이터**
* 내부 필드, 캐시, 계산 값은 숨길 수 있음

```java
class OrderDto {
    Long id;
    int totalPrice;
}
```

→ “이것만 외부로 나간다”가 명확

---

#### 5.2.2 생성자 & 검증 로직이 살아 있다

* JSON → 객체 변환 시:

    * 생성자
    * 검증 로직
    * 팩토리 메서드
      를 **다시 통과**한다

> Item 86에서 말한 **불변식 붕괴 문제 회피**

---

#### 5.2.3 진화가 가능하다

* 필드 추가/제거:

    * JSON은 관대함
    * 서버/클라이언트 버전 불일치에도 비교적 안전
* `Serializable`은 **InvalidClassException 즉사**

---
## QnA
* `Serializable`을 구현했을 때의 문제점이 무엇인가요?
* `Serializable`의 대안은 무엇인가요?